Here is my backend container log:
‚õî No subtitles available for selected dub
[extract:b0a73286-d0f8-4692-8809-168800dd1e58] Extraction done.
[b0a73286-d0f8-4692-8809-168800dd1e58] get_watch_config returned: <starlette.responses.JSONResponse object at 0x7f3f215b5c10>
INFO:     192.168.144.1:33254 - "GET /hd/status/b0a73286-d0f8-4692-8809-168800dd1e58 HTTP/1.1" 200 OK
INFO:     192.168.144.1:55680 - "GET /restore.php HTTP/1.1" 404 Not Found
INFO:     192.168.144.1:55696 - "GET /restore.php HTTP/1.1" 404 Not Found
INFO:     192.168.144.1:57302 - "GET /hd/watch/b0a73286-d0f8-4692-8809-168800dd1e58?lang=ua&dub=%D0%A3%D0%BA%D1%80%D0%B0%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%28Sweet%29 HTTP/1.1" 200 OK
INFO:     192.168.144.1:39540 - "GET /hd/watch-config/b0a73286-d0f8-4692-8809-168800dd1e58 HTTP/1.1" 200 OK
INFO:     192.168.144.1:39542 - "GET /hd/proxy-master/b0a73286-d0f8-4692-8809-168800dd1e58?lang=ua&dub=%D0%A3%D0%BA%D1%80%D0%B0%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%28Sweet%29 HTTP/1.1" 200 OK
INFO:     192.168.144.1:39546 - "GET /hd/proxy-video/b0a73286-d0f8-4692-8809-168800dd1e58/https%3A//orange.stream.voidboost.cc/9272a0ad1ee13d51c8952e76a90d9cef%3A2025052013%3AMkRYNG51d2J1aTRUeERHeTYzMWVMeFgyYk5LZVh2U3pmak1qQndzdFpvYWpFdlErUjFidmcxSmhOYnlXdVF1RGZKTnV6cHZrMFMzanFFb05kL3F0Z0E9PQ%3D%3D/1/1/4/2/4/3/2/cxg30.mp4%3Ahls%3Amanifest.m3u8 HTTP/1.1" 200 OK
INFO:     192.168.144.1:39548 - "GET /hd/proxy-segment/b0a73286-d0f8-4692-8809-168800dd1e58/https%3A//orange.stream.voidboost.cc/9272a0ad1ee13d51c8952e76a90d9cef%3A2025052013%3AMkRYNG51d2J1aTRUeERHeTYzMWVMeFgyYk5LZVh2U3pmak1qQndzdFpvYWpFdlErUjFidmcxSmhOYnlXdVF1RGZKTnV6cHZrMFMzanFFb05kL3F0Z0E9PQ%3D%3D/1/1/4/2/4/3/2/cxg30.mp4%3Ahls%3Aseg-1-v1-a1.ts HTTP/1.1" 200 OK
INFO:     192.168.144.1:39554 - "GET /hd/proxy-video/b0a73286-d0f8-4692-8809-168800dd1e58/https%3A//fingerium.stream.voidboost.cc/322a3e8bc6772d4729890c217adc28a0%3A2025052013%3AMkRYNG51d2J1aTRUeERHeTYzMWVMeFgyYk5LZVh2U3pmak1qQndzdFpvYWpFdlErUjFidmcxSmhOYnlXdVF1RGZKTnV6cHZrMFMzanFFb05kL3F0Z0E9PQ%3D%3D/1/1/4/2/4/3/2/27oc9.mp4%3Ahls%3Amanifest.m3u8 HTTP/1.1" 200 OK

here is my website console:
üì∫ Available HLS Levels: (5)¬†[e, e, e, e, e]
b0a73286-d0f8-4692-8809-168800dd1e58?lang=ua&dub=%D0%A3%D0%BA%D1%80%D0%B0%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%28Sweet%29:63 üéö Quality Options: (5)¬†['Auto', '1080p', '720p', '480p', '360p']

here is my watch.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Watch Movie</title>
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css">
    <style>
        body { background: #111; color: #fff; font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 0; }
        .player-wrapper { max-width: 960px; margin: 20px auto; }
        video { width: 100%; height: 600px; border: none; }
        .dub-buttons { margin-top: 20px; }
        .dub-buttons button {
            background: #333;
            color: white;
            border: 1px solid #666;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 6px;
        }
        .dub-buttons button.active {
            background-color: #007bff;
            border-color: #007bff;
        }
    </style>
</head>
<body>
    <h1>üé¨ Loading your movie...</h1>
    <div class="dub-buttons" id="dub-selector"></div>
    <div class="player-wrapper">
        <video id="player" playsinline controls crossorigin="anonymous"></video>
    </div>
    <p><small>Note: Short ad plays first, then your movie starts automatically.</small></p>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const taskId = window.location.pathname.split("/").pop();
        const lang = urlParams.get("lang") || "ua";
        const defaultDub = urlParams.get("dub") || null;

        const playerElement = document.getElementById('player');
        const dubSelector = document.getElementById('dub-selector');
        const adSource = "/static/ad_dummy.mp4";
        let adPlaying = true;
        let lastTime = 0;

        let hls = null;

        // Initialize Plyr once and don't destroy it
        const player = new Plyr('#player', {
            controls: ['play', 'progress', 'current-time', 'mute', 'volume', 'settings', 'fullscreen'],
            settings: ['quality']
        });

        function setupQualitySelector(hlsInstance) {
            const availableQualities = hlsInstance.levels.map((l) => l.height + 'p').reverse();
            const uniqueQualities = [...new Set(availableQualities)];
            uniqueQualities.unshift('Auto');

            console.log("üì∫ Available HLS Levels:", hlsInstance.levels);
            console.log("üéö Quality Options:", uniqueQualities);

            player.setConfig({
                quality: {
                    default: 'Auto',
                    options: uniqueQualities,
                    forced: true,
                    onChange: (newLabel) => {
                        const level = newLabel === 'Auto' ? -1 : hlsInstance.levels.findIndex(l => l.height + 'p' === newLabel);
                        hlsInstance.currentLevel = level;
                        console.log(`‚úÖ Quality changed to ${newLabel}, index ${level}`);
                    }
                }
            });

            setTimeout(() => {
                player.toggleControls(true);
            }, 100);
        }

        function loadDub(dubName, config) {
            const masterUrl = config.m3u8;
            const subtitles = config.subtitles;

            if (hls) {
                hls.destroy();
                hls = null;
            }

            playerElement.innerHTML = '';
            playerElement.load();

            if (Hls.isSupported()) {
                hls = new Hls();
                hls.loadSource(masterUrl);
                hls.attachMedia(playerElement);
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    setupQualitySelector(hls);
                    player.play();
                });
            } else if (playerElement.canPlayType('application/vnd.apple.mpegurl')) {
                playerElement.src = masterUrl;
                playerElement.addEventListener('loadedmetadata', () => player.play());
            }

            playerElement.innerHTML = '';
            subtitles.forEach(sub => {
                const track = document.createElement('track');
                track.kind = 'subtitles';
                track.label = sub.lang || 'Unknown';
                track.srclang = sub.lang || 'xx';
                track.src = sub.url;
                track.default = false;
                playerElement.appendChild(track);
            });

            document.querySelectorAll(".dub-buttons button").forEach(btn => btn.classList.remove("active"));
            const activeBtn = Array.from(document.querySelectorAll(".dub-buttons button")).find(btn => btn.textContent === dubName);
            if (activeBtn) activeBtn.classList.add("active");
        }

        async function initPlayer() {
            try {
                const res = await fetch(`/hd/watch-config/${taskId}`);
                const config = await res.json();
                const langData = config[lang];

                if (!langData) throw new Error("No dubs found for lang: " + lang);

                for (const dubName in langData) {
                    const btn = document.createElement("button");
                    btn.textContent = dubName;
                    btn.onclick = () => loadDub(dubName, langData[dubName]);
                    dubSelector.appendChild(btn);
                }

                const initialDub = defaultDub && langData[defaultDub] ? defaultDub : Object.keys(langData)[0];
                loadDub(initialDub, langData[initialDub]);
                document.querySelector("h1").textContent = `üé¨ Now Watching: ${initialDub}`;
            } catch (e) {
                document.querySelector("h1").textContent = `‚ùå Failed to load movie.`;
                console.error(e);
            }
        }

        // Start ad first, then main movie
        playerElement.src = adSource;
        playerElement.play();

        playerElement.addEventListener('seeking', () => {
            if (adPlaying && playerElement.currentTime > lastTime + 0.5) {
                playerElement.currentTime = lastTime;
            }
        });

        playerElement.addEventListener('timeupdate', () => {
            if (adPlaying) lastTime = playerElement.currentTime;
        });

        playerElement.addEventListener('ended', () => {
            if (adPlaying) {
                adPlaying = false;
                initPlayer();
            }
        });

        setTimeout(() => {
            if (adPlaying) {
                adPlaying = false;
                initPlayer();
            }
        }, 10000);
    </script>
</body>
</html>

hdrezka_extractor.py:
import asyncio
from camoufox.async_api import AsyncCamoufox
from typing import Dict, List
from backend.video_redirector.utils.redis_client import RedisClient

f2id_to_quality = {
    "1": "360p",
    "2": "480p",
    "3": "720p",
    "4": "1080p",
    "5": "1080pUltra"
}

async def extract_from_hdrezka(url: str, user_lang: str = "ua", task_id: str = None) -> Dict:
    final_result = {user_lang: {}}

    async with AsyncCamoufox(window=(1280, 720), humanize=True, headless=True) as browser:
        page = await browser.new_page()
        await page.goto(url, wait_until="domcontentloaded")
        await asyncio.sleep(0.5)

        # --- Step 1: Find matching dubs ---
        dub_elements = await get_matching_dubs(page, user_lang)

        for dub_name, li_element in dub_elements:
            print(f"\nüéôÔ∏è Extracting for dub: {dub_name}")
            if li_element:
                await li_element.click()
                await asyncio.sleep(1)

            dub_result = {"all_m3u8": [], "subtitles": []}

            await start_listening_for_vtt(page, dub_result,task_id)
            await extract_all_quality_variants(page, dub_result)
            await extract_subtitles_if_available(page, dub_result,task_id=task_id,dub_name=dub_name)

            final_result[user_lang][dub_name] = dub_result

        return final_result

async def get_matching_dubs(page, user_lang: str):
    matching = []
    li_items = await page.query_selector_all("#translators-list li")

    # ‚úÖ Handle NO dubs present at all
    if not li_items:
        print("‚ö†Ô∏è No dubs listed. Assuming single dub mode.")
        return [("üéß Default Dub (no selector)", None)]

    for li in li_items:
        html = await li.inner_html()
        text = await li.text_content()

        if user_lang == "ua" and "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π" in html:
            matching.append((text.strip(), li))

        elif user_lang == "en" and ("–û—Ä–∏–≥–∏–Ω–∞–ª" in html or "Original" in html):
            return [(text.strip(), li)]  # EN returns only one

        elif user_lang == "ru":
            if "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π" in html:
                continue
            if "HDrezka" in html or "–î—É–±–ª—è–∂" in html:
                matching.append((text.strip(), li))
            elif any(x in html.lower() for x in ["–ª–æ—Å—Ç—Ñ–∏–ª—å–º", "–∫–æ–ª–¥—Ñ–∏–ª—å–º", "tvshows"]):
                matching.append((text.strip(), li))

    # fallback: just first dub provided
    if not matching :
        for li in li_items:
            html = await li.inner_html()
            text = await li.text_content()
            return [(text.strip(), li)]

    return matching

async def select_preferred_dub(page, user_lang: str):
    li_items = await page.query_selector_all("#translators-list li")

    for li in li_items:
        html = await li.inner_html()
        if user_lang == "ua" and "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π" in html:
            await li.click()
            return
        elif user_lang == "en" and "–û—Ä–∏–≥–∏–Ω–∞–ª" in html:
            await li.click()
            return
        elif user_lang == "ru" and "–î—É–±–ª—è–∂" in html:
            await li.click()
            return

    print("‚ö†Ô∏è No matching dub found for user_lang. Using default active.")


async def start_listening_for_vtt(page, extracted: Dict,task_id):
    vtt_captured = False
    async def handle_vtt_response(response):
        nonlocal vtt_captured
        if vtt_captured:
            return
        url = response.url
        if url.endswith(".vtt"):
            proxy_url = f"/hd/subs/{task_id}.vtt"
            print(f"[üéØ] Found subtitle VTT (initial): {url}")
            extracted["subtitles"].append({
                "url": proxy_url,
                "headers": dict(response.request.headers),
                "referer": response.request.headers.get("referer")
            })
            vtt_captured = True

    page.on("response", handle_vtt_response)


async def extract_subtitles_if_available(page, extracted: Dict, task_id: str,dub_name: str):
    # Step 1: Check if subtitles are even shown in UI
    has_subs = await page.evaluate("""
            () => {
                const el = document.querySelector("#cdnplayer_control_cc");
                return el && el.style.display === "block";
            }
        """)

    if not has_subs:
        print("‚õî No subtitles available for selected dub")
        return

    print("üü° Subtitles detected")

    # Step 2: Click the subtitles menu (CC button)
    try:
        await page.evaluate("""
            (xpath) => {
                const el = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                if (el) el.click();
            }
        """, arg='//*[@id="cdnplayer_control_cc"]/pjsdiv[3]')
        print("‚úÖ Forced subtitle button click via JS")
    except Exception as e:
        print(f"‚ö†Ô∏è Subtitle button failed to become interactable: {e}")
        return

    # Step 3: Setup shared subtitle event listener
    subtitle_state = {"current_lang": None}
    vtt_event = asyncio.Event()

    async def handle_vtt_response(response):
        if response.url.endswith(".vtt") and subtitle_state["current_lang"] and response.status == 200:
            real_url = response.url
            lang_code = subtitle_state["current_lang"]
            proxy_url = f"/hd/subs/{task_id}/{dub_name}/{lang_code}.vtt"

            # Save to Redis
            redis = RedisClient.get_client()
            await redis.set(f"subs:{task_id}:{dub_name}:{lang_code}", real_url, ex=3600)

            extracted["subtitles"].append({
                "url": proxy_url,
                "lang": lang_code
            })

            print(f"[üéØ] Captured subtitle {subtitle_state['current_lang']} ‚Üí {response.url}")
            subtitle_state["current_lang"] = None
            vtt_event.set()

    page.on("response", handle_vtt_response)

    subtitle_items = await page.query_selector_all("[f2id]")

    index_of_already_catched_subs = None
    #Step 4: Check if any subtitle is already selected (highlighted with special SVG)
    for idx, item in enumerate(subtitle_items):
        index_of_already_catched_subs = idx
        highlight = await item.query_selector('pjsdiv svg')
        if highlight:
            lang = await item.text_content()
            print(f"üü¢ Already active subtitle detected: {lang}")
            if extracted["subtitles"]:
                extracted["subtitles"][0]["lang"] = lang
            break

    # Step 5: Iterate through subtitle options (skip first & last)
    for idx in range(1, len(subtitle_items) - 1):
        # if currently selected subs is first in list we need to close mini menu and skip this iteration
        if index_of_already_catched_subs == 1 and index_of_already_catched_subs == idx:
            await page.evaluate("""
                                    (xpath) => {
                                        const el = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                                        if (el) el.click();
                                    }
                                """, arg='//*[@id="cdnplayer_control_cc"]/pjsdiv[3]')
            await asyncio.sleep(1)
            continue

        # Reopen subtitle menu before each click, except first iteration when it is already opened
        if idx != 1:
            await page.evaluate("""
                (xpath) => {
                    const el = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                    if (el) el.click();
                }
            """, arg='//*[@id="cdnplayer_control_cc"]/pjsdiv[3]')
            await asyncio.sleep(1)

        subtitle_items = await page.query_selector_all("[f2id]")
        fresh_item = subtitle_items[idx]
        f2id_val = await fresh_item.get_attribute("f2id")

        # Extract language label safely
        lang = await fresh_item.text_content()
        subtitle_state["current_lang"] = lang
        vtt_event.clear()

        # Click subtitle
        await page.evaluate(
            """
            (f2id) => {
                const el = document.querySelector(`[f2id="${f2id}"]`);
                if (el) el.click();
            }
            """,
            arg=f2id_val
        )
        print(f"üîç Clicked subtitle option f2id={f2id_val} ({lang})")

        try:
            await asyncio.wait_for(vtt_event.wait(), timeout=10)
        except asyncio.TimeoutError:
            print(f"‚ö†Ô∏è No .vtt received for subtitle: {lang}")

        await asyncio.sleep(0.3)


async def extract_all_quality_variants(page, extracted: Dict):
    print("üì• Extracting all quality variants...")

    quality_button_xpath = '//*[@id="oframecdnplayer"]/pjsdiv[15]/pjsdiv[3]'
    f2id_list = ["1", "2", "3", "4", "5"]

    async def click_xpath(xpath: str):
        await page.evaluate("""
            (xpath) => {
                const el = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                if (el) el.click();
            }
        """, arg=xpath)

    quality_state = {"current": None}
    quality_event = asyncio.Event()

    async def try_f2id(f2idx: str):
        quality_label = f2id_to_quality.get(f2idx)
        quality_state["current"] = quality_label
        quality_event.clear()

        await click_xpath(quality_button_xpath)
        await asyncio.sleep(0.3)

        await page.evaluate("""() => {
            const btn = document.querySelector('[fid="1"]');
            if (btn) btn.click();
        }""")
        await asyncio.sleep(0.3)

        el = await page.query_selector(f'[f2id="{f2idx}"]')
        if not el:
            print(f"‚ùå Element for f2id={f2idx} not found")
            return False

        # Click quality button first
        await page.evaluate("""(f2idx) => {
            const el = document.querySelector(`[f2id="${f2idx}"]`);
            if (el) el.click();
        }""", arg=f2idx)

        print(f"[üîÅ] Clicked quality option f2id={f2idx} ({quality_label})")

        # Attach listener only AFTER click
        async def handle_response(response):
            url = response.url
            if (
                    response.status == 200
                    and ".m3u8" in url
                    and "manifest" in url
                    and quality_state["current"]
            ):
                headers = dict(response.request.headers)
                m3u8_data = {
                    "quality": quality_state["current"],
                    "url": url,
                    "headers": headers,
                    "referer": headers.get("referer")
                }
                if m3u8_data not in extracted["all_m3u8"]:
                    extracted["all_m3u8"].append(m3u8_data)
                    print(f"[üé•] {quality_state['current']} ‚Üí {url}")
                    quality_event.set()

        page.on("response", handle_response)

        try:
            await asyncio.wait_for(quality_event.wait(), timeout=5)
            page.remove_listener("response", handle_response)
            return True
        except asyncio.TimeoutError:
            print(f"‚ö†Ô∏è Timeout waiting for .m3u8 after clicking {quality_label}")
            page.remove_listener("response", handle_response)
            return False

    MAX_RETRIES = 3
    retry_count = 0
    missing_set = set(f2id_list)

    while missing_set and retry_count < MAX_RETRIES:
        print(f"üîÅ Retry pass #{retry_count + 1} for missing qualities: {sorted(missing_set)}")
        current_missing = set()

        for f2id in sorted(missing_set):
            # Reset state if only 1 retry left
            if len(missing_set) == 1:
                for alt in f2id_list:
                    if alt != f2id:
                        print(f"üîÑ Resetting player by clicking alt f2id={alt} before retrying f2id={f2id}")
                        await try_f2id(alt)  # Ignore result
                        break

            success = await try_f2id(f2id)
            if not success:
                current_missing.add(f2id)

        missing_set = current_missing
        retry_count += 1

    if missing_set:
        print(f"‚ùå Failed to extract the following qualities after {MAX_RETRIES} retries: {sorted(missing_set)}")

    quality_state["current"] = None


# Example usage:
if __name__ == "__main__":
    async def test():
        movie_url = "https://hdrezka.ag/films/fiction/58225-bednye-neschastnye-2023.html"
        result = await extract_from_hdrezka(movie_url, user_lang="ua")
        print(result)

    asyncio.run(test())

hdrezka_proxy_handler.py:
import aiohttp
from fastapi import Request, Response
from starlette.responses import StreamingResponse, PlainTextResponse
from urllib.parse import unquote, quote, urljoin
from backend.video_redirector.utils.redis_client import RedisClient

FORWARD_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0",
    "Accept": "*/*",
    "Accept-Language": "en-US,en;q=0.5",
    "Accept-Encoding": "identity",  # Disable compression for video chunks
    "Origin": "https://hdrezka.ag",
    "Referer": "https://hdrezka.ag/",
    "Connection": "keep-alive",
    "Sec-Fetch-Dest": "empty",
    "Sec-Fetch-Mode": "cors",
    "Sec-Fetch-Site": "cross-site"
}

async def proxy_video(movie_id: str, request: Request) -> Response:
    """
    Handles /hd/proxy-video/{movie_id}/{encoded_real_m3u8_url}
    """
    full_path = request.url.path
    encoded_url = full_path.split(f"/hd/proxy-video/{movie_id}/", 1)[-1]
    real_url = unquote(encoded_url)

    return await fetch_and_rewrite_m3u8(real_url, movie_id)


async def proxy_segment(movie_id: str, segment_encoded: str, request: Request) -> Response:
    """
    Handles .ts segment requests by downloading and forwarding the content.
    """

    redis = RedisClient.get_client()
    base_url = await redis.get(f"extract:{movie_id}:segment_base")
    if not base_url:
        print(f"[Segment Error] Base URL not found for movie_id={movie_id}")
        return PlainTextResponse("Base URL missing", status_code=500)


    real_url = urljoin(base_url, unquote(segment_encoded))
    session_timeout = aiohttp.ClientTimeout(total=15)

    try:
        async with aiohttp.ClientSession(timeout=session_timeout) as session:
            async with session.get(real_url, headers=FORWARD_HEADERS) as resp:
                if resp.status != 200:
                    print(f"[Segment Error] {real_url} returned {resp.status}")
                    return PlainTextResponse("Segment failed", status_code=resp.status)

                content_type = resp.headers.get("Content-Type", "video/MP2T")
                body = await resp.read()
                return Response(content=body, media_type=content_type, status_code=200)

    except Exception as e:
        print(f"[Proxy Segment Error]: {e} | Segment: {real_url}")
        return PlainTextResponse("Internal proxy error", status_code=500)


async def fetch_and_rewrite_m3u8(url: str, movie_id: str) -> Response:
    session_timeout = aiohttp.ClientTimeout(total=30)
    base_url = url.rsplit('/', 1)[0] + '/'

    redis = RedisClient.get_client()
    await redis.set(f"extract:{movie_id}:segment_base", base_url, ex=3600)

    try:
        async with aiohttp.ClientSession(timeout=session_timeout) as session:
            async with session.get(url, headers=FORWARD_HEADERS) as remote_response:
                if remote_response.status != 200:
                    return PlainTextResponse(f"Error fetching m3u8: {remote_response.status}", status_code=remote_response.status)

                m3u8_text = await remote_response.text()

                if not "#EXTM3U" in m3u8_text:
                    print(f"[proxy_video] Not a valid .m3u8 playlist: {url}")
                    return PlainTextResponse("Not a valid .m3u8 playlist", status_code=500)

                if not url.endswith(".m3u8"):
                    print("[proxy_video] URL doesn't end with .m3u8 ‚Äî skipping rewrite.")
                    return PlainTextResponse("Not a playlist URL", status_code=400)

                lines = m3u8_text.splitlines()
                rewritten_lines = []

                for line in lines:
                    stripped = line.strip()

                    # Leave comments and tags as-is
                    if stripped.startswith("#") or not stripped:
                        rewritten_lines.append(stripped)
                        continue

                    # Build full URL from relative path
                    if not stripped.startswith("http"):
                        full_url = urljoin(base_url, stripped)
                    else:
                        full_url = stripped

                    encoded = quote(full_url, safe='')

                    # Route based on type
                    if ".m3u8" in stripped:
                        proxy_url = f"/hd/proxy-video/{movie_id}/{encoded}"
                    else:
                        proxy_url = f"/hd/proxy-segment/{movie_id}/{encoded}"

                    rewritten_lines.append(proxy_url)

                rewritten_m3u8 = "\n".join(rewritten_lines)

                if ".hls:" in url:
                    base_url = url.rsplit('/', 1)[0] + '/'
                    await redis.set(f"extract:{movie_id}:segment_base", base_url, ex=3600)

                return PlainTextResponse(content=rewritten_m3u8, media_type="application/vnd.apple.mpegurl")

    except Exception as e:
        print(f"[M3U8 Proxy Error]: {e}")
        return PlainTextResponse("Internal proxy error", status_code=500)

hdrezka_routes.py:
import json
from fastapi import APIRouter, Request, BackgroundTasks, HTTPException, Response
from fastapi.responses import HTMLResponse,JSONResponse,PlainTextResponse
from pydantic import BaseModel
from uuid import uuid4
from urllib.parse import quote

from backend.video_redirector.hdrezka.hdrezka_extractor import extract_from_hdrezka
from backend.video_redirector.hdrezka.hdrezka_proxy_handler import proxy_video, proxy_segment
from backend.video_redirector.utils.templates import templates
from backend.video_redirector.utils.redis_client import RedisClient

class ExtractRequest(BaseModel):
    url: str
    lang: str = "ua"

router = APIRouter(prefix="/hd", tags=["HDRezka watch+download video"])

async def extract_and_generate_master_m3u8(task_id: str, url: str, lang: str):
    redis = RedisClient.get_client()

    try:
        # Step 1: Extraction
        result = await extract_from_hdrezka(url, user_lang=lang, task_id=task_id)
        await redis.set(f"extract:{task_id}:status", "extracted", ex=3600)
        await redis.set(f"extract:{task_id}:raw", json.dumps(result), ex=3600)
        print(f"[extract:{task_id}] Extraction done.")
    except Exception as e:
        await redis.set(f"extract:{task_id}:status", "error", ex=3600)
        await redis.set(f"extract:{task_id}:error", str(e), ex=3600)
        print(f"[extract:{task_id}] Extraction error: {e}")

    try:
        config_response = await get_watch_config(task_id)

        if not config_response:
            raise Exception("‚ùå watch_config was empty or None")

        if isinstance(config_response, JSONResponse):
            config = config_response.body.decode()
        else:
            config = json.dumps(config_response)

        print(f"[{task_id}] get_watch_config returned:", config_response)
        await redis.set(f"extract:{task_id}:watch_config", config, ex=3600)
        await redis.set(f"extract:{task_id}:status", "done", ex=3600)
    except Exception as e:
        print(f"[extract:{task_id}] Error building watch_config: {e}")
        await redis.set(f"extract:{task_id}:status", "error", ex=3600)
        await redis.set(f"extract:{task_id}:error", f"watch_config error: {str(e)}", ex=3600)


@router.post("/extract")
async def extract_entry(data: ExtractRequest, background_tasks: BackgroundTasks):
    task_id = str(uuid4())
    redis = RedisClient.get_client()
    await redis.set(f"extract:{task_id}:status", "pending", ex=3600)

    background_tasks.add_task(extract_and_generate_master_m3u8, task_id, data.url, data.lang)
    print(f"[extract:{task_id}] Extraction started for {data.url}")

    return {"task_id": task_id, "status": "started"}

@router.get("/status/{task_id}")
async def check_status(task_id: str):
    redis = RedisClient.get_client()

    status = await redis.get(f"extract:{task_id}:status")
    if not status:
        raise HTTPException(status_code=404, detail="Task not found")

    if status == "done":
        data = await redis.get(f"extract:{task_id}:watch_config")
        return {"status": status, "data": json.loads(data)}
    elif status == "error":
        error = await redis.get(f"extract:{task_id}:error")
        return {"status": status, "error": error}
    else:
        return {"status": status}

@router.get("/watch-config/{task_id}")
async def get_watch_config(task_id: str):
    redis = RedisClient.get_client()

    status = await redis.get(f"extract:{task_id}:status")

    if status == "done":
        raw_data = await redis.get(f"extract:{task_id}:watch_config")
        if not raw_data:
            raise HTTPException(status_code=404, detail="Config missing despite status=done")
        try:
            return JSONResponse(content=json.loads(raw_data))
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Corrupted config: {e}")

    if status == "pending":
        raise HTTPException(status_code=400, detail="Extraction not completed yet")

    elif status == 'extracted':

        raw_data = await redis.get(f"extract:{task_id}:raw")
        if not raw_data:
            raise HTTPException(status_code=404, detail="Extraction result not found")

        parsed = json.loads(raw_data)
        watch_config = {}

        for lang, dubs in parsed.items():
            watch_config[lang] = {}
            for dub_name, dub_data in dubs.items():
                qualities = dub_data.get("all_m3u8", [])
                subtitles = dub_data.get("subtitles", [])

                # Build master m3u8 content
                lines = ["#EXTM3U"]
                for item in qualities:
                    quality = item.get("quality")
                    url = item.get("url")
                    if not quality or not url:
                        continue
                    encoded = quote(url, safe="")

                    bandwidth = {
                        "360p": 800000,
                        "480p": 1400000,
                        "720p": 2800000,
                        "1080p": 5000000,
                        "1080pUltra": 6500000
                    }.get(quality, 1000000)

                    resolution = {
                        "360p": "640x360",
                        "480p": "854x480",
                        "720p": "1280x720",
                        "1080p": "1920x1080",
                        "1080pUltra": "1920x1080"
                    }.get(quality, "1280x720")

                    lines.append(f"#EXT-X-STREAM-INF:BANDWIDTH={bandwidth},RESOLUTION={resolution}")
                    lines.append(f"/hd/proxy-video/{task_id}/{encoded}")

                master_m3u8 = "\n".join(lines)

                await redis.set(f"master_m3u8:{task_id}:{lang}:{dub_name}", master_m3u8, ex=28800)

                watch_config[lang][dub_name] = {
                    "m3u8": f"/hd/proxy-master/{task_id}?lang={lang}&dub={quote(dub_name)}",
                    "subtitles": subtitles
                }

        return JSONResponse(content=watch_config)

@router.get("/proxy-master/{task_id}")
async def serve_master_m3u8(task_id: str, lang: str, dub: str):
    redis = RedisClient.get_client()
    key = f"master_m3u8:{task_id}:{lang}:{dub}"
    master_m3u8 = await redis.get(key)
    if not master_m3u8:
        return PlainTextResponse("Master M3U8 not found", status_code=404)

    return PlainTextResponse(content=master_m3u8, media_type="application/vnd.apple.mpegurl")

# --- New proxy-video route for individual segments ---
@router.get("/proxy-video/{movie_id}/{encoded_path:path}")
async def proxy_video_router(movie_id: str, encoded_path: str, request: Request):
    if encoded_path.endswith(".ts"):
        return await proxy_segment(movie_id, encoded_path, request)
    else:
        return await proxy_video(movie_id, request)

@router.get("/proxy-segment/{movie_id}/{encoded_path:path}")
async def proxy_segment_router(movie_id: str, encoded_path: str, request: Request) -> Response :
    return await proxy_segment(movie_id, encoded_path, request)


#TODO: DO we really need movie_id? We probably should change it to smth else

# --- Updated watch route ---
@router.get("/watch/{movie_id}", response_class=HTMLResponse)
async def watch_movie(movie_id: str, request: Request):
    return templates.TemplateResponse("hdrezka/watch.html", {
        "request": request,
        "movie_id": movie_id,
    })

@router.get("/download/{movie_id}", response_class=HTMLResponse)
async def redirect_download(movie_id: str, request: Request):
    # TODO: create download logic
    return

